---
title: 程序填空小测试
tags: [C++]
show_author_profile: false
---
~~不知道为什么，和标准答案对比，我应该得**12分**，而我的最终分数（评测分）为**3分**。 _Why?_ _Why?_ _Why?_~~

[题目的源代码可以在这里查看](https://www.luogu.com.cn/paste/jdfaba26)

### 第一题
#### 螺旋矩阵输出（5小题）

注：```vis```是```visit```的简称

##### （1）正确

##### （2）错误

原题：

**2** 处应填：

A. ```vis[x][y] = 1``` B. ```print(x, y, flag + 1)``` C. ```print(x, y+1, flag)``` D. ```vis[x][y] = 0```

正确答案：A

在```cout << a[x][y] << " ";```之后需要将```a[x][y]```标记为已访问过，即```vis[x][y] = 1;```。23，25行已经调用过下层递归了（即```print(x, y, flag)```）,在这里再调用一次~~就有点不太像话了~~不符合实际情况，所以不能选B或C。

##### （3）正确

##### （4）错误

原题：

**4** 处应填：

```A. vis[x][y] == 1``` B. ```vis[x][y] == 0```
C. ```vis[nxt_x][nxt_y] == 0``` D. ```vis[nxt_x][nxt_y] == 1```

正确答案：D

**4** 处所对应的$\mathit if$语句的内容为```print(x, y, (flag + 1) % 4);```。此处```(flag + 1) % 4```为顺时针旋转$90^o$（```0->1，1->2，2->3，3->0```，转到下一个方向，这也是这段代码如何实现转向的原理）。之所以要转向，是因为下一个位置无法达到，也就说明下一个位置已经被访问过，也被输出过，翻译成代码就是```vis[nxt_x][nxt_y] == 1```。

$\mathit else$语句中的内容表示如果没有上述情况，则正常走下一个。

##### （5）错误

原题：

**5** 处应填：

A. ```print(1, 1, 0)``` B. ```print(0, 0, 0)``` C. ```print(1, 1, 1)``` D. ```print(0, 0, 1)```

正确答案：A

这是一道送分题，~~非常简单，~~但即便是送分题，我还是做错了。

应该注意：矩阵的坐标是**从(1,1)开始**，并不是从(0,0)开始，而且一开始画图方向朝右，所以```flag==0```。~~考虑到这些，就3分到手了~~

### 第二题
#### 栅栏涂色（5小题）

注：```res```是```result```的简称

##### （1）正确

##### （2）错误

原题：

**2** 处代码应该填：

A. ```get_st(i, minn);``` B. ```i``` C. ```i + 1``` D. ```res```

正确答案：B

第18行（也就是上一行）进行了上一段递归，那第19行就需进行下一段递归，则需要将```st```替换为下一段递归的起点，也就是```i```，则选B。

##### （3）错误

原题：

**3** 处代码应该填：

A. ```dfs(st, r-1)``` B. ```dfs(st+1, r)``` C. ```dfs(st, r)``` D. ```dfs(st+1, r-1)```

正确答案：C

22行$\mathit if$语句的内容为```st<=r```，说明还有一些“栅栏”（最后一段）没有开始递归。也就是最后没有```minn```，就把最后的全部进行递归，应该到```r```，而不是到```r-1```
##### （4）错误

原题：

**4** 处代码应填：

A. ```res+1``` B. ```res```
C. ```res + dfs(l, st) + dfs(st, r)``` D. ```res + dfs(l, st - 1) + dfs(st + 1, r)```

正确答案：C

之前的几段递归求了所有的和，但最后```return```的并不是```res```，而是将```res```加上第一段递归（从```l```到```st```），再加上第二段递归（从```st```到```r```）。

##### （5）正确

_本篇文章到此结束_



